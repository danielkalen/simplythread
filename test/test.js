// Generated by CoffeeScript 1.10.0
var FN, basePath, expect, should;

mocha.setup('tdd');

mocha.slow(400);

mocha.bail();

expect = chai.expect;

should = chai.should();

basePath = location.origin + location.pathname.replace(/\/[^\/]+$/, '');

basePath = basePath.replace(/\/test$/, '');

if (window.isKarma || window.isSauce) {
  basePath += '/base';
}

Promise.config({
  warnings: false
});

FN = {
  err: function() {
    throw new Error('sample error');
  },
  subtracter: function(a, b) {
    return a - b;
  },
  adder: function(a, b) {
    return a + b;
  },
  adderPromise: function(a, b) {
    return new Promise(function(resolve) {
      return resolve(a + b);
    });
  },
  adderPromiseFail: function(a, b) {
    return new Promise(function(resolve, reject) {
      return reject(a + b);
    });
  },
  delayedPromise: function(a, b) {
    return new Promise(function(resolve) {
      return setTimeout((function() {
        return resolve(a + b);
      }), 150 * Math.random());
    });
  },
  context: function(num) {
    return this.prop + num;
  },
  contextReturn: function() {
    return this;
  },
  globals: function(propName) {
    return this[propName];
  },
  globalsInvoker: function(propName, arg) {
    return this[propName](arg);
  },
  invoker: function(a, b) {
    return a(b);
  },
  emitter: function() {
    threadEmit('someEvent', 'first');
    setTimeout(function() {
      return threadEmit('diffEvent', 'second');
    }, 20);
    setTimeout(function() {
      return threadEmit('someEvent', 'third');
    }, 35);
    return setTimeout(function() {
      return threadEmit('diffEvent', 'fourth');
    }, 45);
  }
};

suite("SimplyThread", function() {
  suite(".create()", function() {
    test("will create a new thread with a given function", function() {
      var adderThread;
      adderThread = SimplyThread.create(FN.adder);
      adderThread.should.have.keys('fn', 'fnString', 'status');
      adderThread.fn.should.equal(FN.adder);
      adderThread.status.should.equal('active');
      return adderThread.kill();
    });
    return test("will create a new thread without a function", function() {
      var emptyThread;
      emptyThread = SimplyThread.create();
      emptyThread.should.have.keys('fn', 'fnString', 'status');
      should.not.exist(emptyThread.fn);
      return emptyThread.kill();
    });
  });
  suite(".list()", function() {
    return test("will return an array containing all running threads", function() {
      var sampleThreads;
      sampleThreads = [SimplyThread.create(), SimplyThread.create(), SimplyThread.create()];
      SimplyThread.list().should.be.an('array');
      SimplyThread.list().should.have.members(sampleThreads);
      return sampleThreads.forEach(function(thread) {
        return thread.kill();
      });
    });
  });
  suite(".killAll()", function() {
    return test("will kill all running threads", function() {
      var sampleThreads;
      SimplyThread.list().length.should.equal(0);
      sampleThreads = [SimplyThread.create(), SimplyThread.create(), SimplyThread.create()];
      SimplyThread.list().length.should.equal(3);
      SimplyThread.killAll().should.be["true"];
      SimplyThread.list().should.not.have.members(sampleThreads);
      return SimplyThread.list().length.should.equal(0);
    });
  });
  return suite("Thread", function() {
    var adderPromiseFailThread, adderPromiseThread, adderThread, contextReturnThread, contextThread, delayedPromiseThread, emitterThread, emptyThread, errThread, globalsInvokerThread, globalsThread, invokerThread, subtracterThread;
    emptyThread = errThread = adderThread = adderPromiseThread = adderPromiseFailThread = delayedPromiseThread = subtracterThread = contextThread = contextReturnThread = globalsThread = globalsInvokerThread = invokerThread = emitterThread = null;
    suiteSetup(function() {
      emptyThread = SimplyThread.create();
      errThread = SimplyThread.create(FN.err);
      adderThread = SimplyThread.create(FN.adder);
      adderPromiseThread = SimplyThread.create(FN.adderPromise);
      adderPromiseFailThread = SimplyThread.create(FN.adderPromiseFail);
      delayedPromiseThread = SimplyThread.create(FN.delayedPromise);
      subtracterThread = SimplyThread.create(FN.subtracter);
      contextThread = SimplyThread.create(FN.context);
      contextReturnThread = SimplyThread.create(FN.contextReturn);
      globalsThread = SimplyThread.create(FN.globals);
      globalsInvokerThread = SimplyThread.create(FN.globalsInvoker);
      invokerThread = SimplyThread.create(FN.invoker);
      return emitterThread = SimplyThread.create(FN.emitter);
    });
    suite(".run()", function() {
      test("will execute the given function with given arguments and return a thenable object (promise)", function() {
        var promise;
        promise = adderThread.run(10, 20);
        promise.then.should.be.a('function');
        promise["catch"].should.be.a('function');
        return promise.then(function(result) {
          return result.should.equal(30);
        });
      });
      test("will execute the same way with functions that return a promise", function() {
        var promise;
        promise = adderPromiseThread.run(10, 20);
        promise.then.should.be.a('function');
        promise["catch"].should.be.a('function');
        return promise.then(function(result) {
          return result.should.equal(30);
        });
      });
      test("will avoid conflicts with other runs of the same thread", function() {
        return Promise.all([delayedPromiseThread.run(5, 10), delayedPromiseThread.run(25, 75), delayedPromiseThread.run(100, 12)]).then(function(results) {
          results[0].should.equal(15);
          results[1].should.equal(100);
          return results[2].should.equal(112);
        });
      });
      test("will return an error if no function was given during thread creation or manually set", function() {
        return emptyThread.run()["catch"](function(err) {
          return err.should.be.an('error');
        });
      });
      test("if an error occured in the thread the run promise should be rejected", function() {
        return errThread.run()["catch"](function(err) {
          return err.should.be.an('error');
        });
      });
      test("will return a rejected promise if the given function returned a rejected promise", function() {
        return adderPromiseFailThread.run(10, 20)["catch"](function(failure) {
          return failure.should.equal(30);
        });
      });
      test("can pass functions as arguments", function() {
        var promise, sampleFn;
        sampleFn = function(string) {
          return string.toUpperCase();
        };
        promise = invokerThread.run(sampleFn, 'simplythread');
        promise.then.should.be.a('function');
        promise["catch"].should.be.a('function');
        return promise.then(function(result) {
          return result.should.equal('SIMPLYTHREAD');
        });
      });
      return test("can return functions as results", function() {
        var curryFn, promise;
        curryFn = function(string) {
          return function(string) {
            return string.toUpperCase();
          };
        };
        promise = invokerThread.run(curryFn, 'simplythread');
        promise.then.should.be.a('function');
        promise["catch"].should.be.a('function');
        return promise.then(function(result) {
          result.should.be.a('function');
          return result('simplythread').should.equal('SIMPLYTHREAD');
        });
      });
    });
    suite(".on()", function() {
      return test("Will register an event and its callback to be invoked every time threadEmit(event) is invoked from the thread's main function", function() {
        return new Promise((function(_this) {
          return function(resolve) {
            var emitCount;
            _this.slow(700);
            emitCount = {
              someEvent: 0,
              diffEvent: 0
            };
            emitterThread.on('someEvent', function(payload) {
              if (emitCount.someEvent++) {
                return payload.should.equal('third');
              } else {
                return payload.should.equal('first');
              }
            });
            emitterThread.on('diffEvent', function(payload) {
              if (emitCount.diffEvent++) {
                return payload.should.equal('fourth');
              } else {
                return payload.should.equal('second');
              }
            });
            return emitterThread.run().then(function() {
              return setTimeout(function() {
                emitCount.someEvent.should.equal(2);
                emitCount.diffEvent.should.equal(2);
                return resolve();
              }, 75);
            });
          };
        })(this));
      });
    });
    suite(".setFn()", function() {
      test("will execute empty threads normally if a function was later set with .setFn", function() {
        var myEmptyThread;
        myEmptyThread = SimplyThread.create();
        return myEmptyThread.setFn(FN.adder).run(20, 40).then(function(result) {
          result.should.equal(60);
          return myEmptyThread.kill();
        });
      });
      test("will replace the existing function with the one specified", function() {
        var notEmptyThread;
        notEmptyThread = SimplyThread.create(FN.adder);
        return notEmptyThread.setFn(FN.subtracter).run(100, 75).then(function(result) {
          result.should.equal(25);
          return notEmptyThread.kill();
        });
      });
      return test("will use the second argument, if passed, as the context of the function", function() {
        var myContextReturnThread;
        myContextReturnThread = SimplyThread.create();
        return myContextReturnThread.setFn((function() {
          return this;
        }), {
          'prop': 5
        }).run().then(function(result) {
          result.should.be.an('object');
          result.should.have.keys('prop');
          return result.prop.should.equal(5);
        });
      });
    });
    suite(".setGlobals()", function() {
      test("receives an object as an argument and sets all of its values to the thread's global scope", function() {
        return globalsThread.setGlobals({
          'prop': 1000
        }).run('prop').then(function(result) {
          return result.should.equal(1000);
        });
      });
      return test("can set functions to be set as global variables", function() {
        return globalsInvokerThread.setGlobals({
          'someFn': function(string) {
            return string.toUpperCase();
          }
        }).run('someFn', 'simplythread').then(function(result) {
          return result.should.equal('SIMPLYTHREAD');
        });
      });
    });
    suite(".setScripts()", function() {
      test("will take an array of strings that act as network paths for external scripts and loads them inside the thread's global scope", function() {
        return globalsThread.setScripts([basePath + "/test/samplescript.js"]).run('sampleScriptName').then(function(result) {
          return result.should.equal('just a sample script');
        });
      });
      test("will load an external script when provided in a non-array format value", function() {
        return globalsThread.setScripts(basePath + "/test/samplescript.js").run('sampleScriptName').then(function(result) {
          return result.should.equal('just a sample script');
        })["catch"](function(err) {
          return console.log(err);
        });
      });
      test("will reject .run() calls' promises if failed to load any of the provided scripts", function() {
        return globalsThread.setScripts([basePath + "/test/samplescript.js", basePath + "/test/nonexistent.js"]).run('sampleScriptName').then(function(result) {
          true.should.be["false"];
          return result.should.equal('just a sample script');
        })["catch"](function(err) {
          return err.should.be.an.error;
        });
      });
      test("can load an NPM module when given a module's name with a 'MODULE:' prefix", function() {
        if (window.location.protocol === 'file:') {
          return this.skip();
        } else {
          return SimplyThread.create(function(arr) {
            return lodash.join(arr, '~');
          }).setScripts("MODULE:lodash").run(['a', 'b', 'c']).then(function(result) {
            return result.should.equal('a~b~c');
          });
        }
      });
      test("can load an NPM module and expose it under a different name using 'MODULE:xyz#custonName'", function() {
        if (window.location.protocol === 'file:') {
          return this.skip();
        } else {
          return SimplyThread.create(function(timeFrame) {
            return TimeUNITS[timeFrame] * 3;
          }).setScripts("MODULE:timeunits#TimeUNITS").run('hour').then(function(result) {
            return result.should.equal(10800000);
          });
        }
      });
      test("can accept functions that will be invoked immediatly on the thread's global scope", function() {
        return globalsThread.setScripts([
          function() {
            return this.scriptFromFn = 'just a sample script from a function';
          }
        ]).run('scriptFromFn').then(function(result) {
          return result.should.equal('just a sample script from a function');
        });
      });
      return test("if passed functions that return a promise, that promise will be followed", function() {
        return globalsThread.setScripts([
          function() {
            return new Promise((function(_this) {
              return function(resolve) {
                return setTimeout(function() {
                  return resolve(_this.scriptFromFn = 'sample script via promise');
                });
              };
            })(this));
          }
        ]).run('scriptFromFn').then(function(result) {
          return result.should.equal('sample script via promise');
        });
      });
    });
    suite(".setContext()", function() {
      test("will set the thread's function's 'this' keyword to the provided argument", function() {
        return contextThread.setContext({
          'prop': 5
        }).run(8).then(function(result) {
          return result.should.equal(13);
        });
      });
      test("will use contexts that have functions", function() {
        return contextReturnThread.setContext({
          'name': 'someObject',
          'fn': function() {
            return 'blabla';
          }
        }).run().then(function(result) {
          result.should.be.an('object');
          should.exist(result.name);
          should.exist(result.fn);
          result.name.should.equal('someObject');
          return result.fn().should.equal('blabla');
        });
      });
      return test("will use contexts that have circular references and will omit DOM objects", function() {
        var obj, sub;
        obj = {
          subA: {
            'prop1': 'prop1',
            'prop2': 'prop2',
            'prop3': 'prop3'
          },
          subB: {
            'prop1': 'prop1',
            'prop2': 'prop2',
            'prop3': 'prop3'
          },
          subC: {
            'prop1': 'prop1',
            'prop2': 'prop2',
            'prop3': 'prop3'
          }
        };
        for (sub in obj) {
          obj[sub].parent = obj;
          obj[sub].self = obj[sub];
          obj[sub].DOM = jQuery('body')[0];
          obj[sub].DOM$ = jQuery('body');
        }
        obj.self = obj;
        return contextReturnThread.setContext(obj).run().then(function(result) {
          result.should.be.an('object');
          should.exist(result.self);
          result.subA.should.be.an('object');
          result.subB.should.be.an('object');
          result.subC.should.be.an('object');
          should.exist(result.subA.prop1);
          should.exist(result.subB.prop2);
          should.exist(result.subC.prop3);
          should.exist(result.subA.self);
          should.exist(result.subB.self);
          should.exist(result.subC.self);
          should.exist(result.subA.parent);
          should.exist(result.subB.parent);
          should.exist(result.subC.parent);
          should.exist(result.subA.DOM$);
          should.exist(result.subB.DOM$);
          should.exist(result.subC.DOM$);
          should.not.exist(result.subA.DOM);
          should.not.exist(result.subB.DOM);
          should.not.exist(result.subC.DOM);
          result.self.should.equal(result);
          result.subA.parent.should.equal(result);
          result.subA.self.should.equal(result.subA);
          result.subB.self.should.equal(result.subB);
          return result.subC.self.should.equal(result.subC);
        });
      });
    });
    suite(".kill()", function() {
      test("will terminate the thread and set its status to 'dead'", function() {
        var sampleThread;
        sampleThread = SimplyThread.create();
        sampleThread.status.should.equal('active');
        sampleThread.kill();
        return sampleThread.status.should.equal('dead');
      });
      return test("will cause any function runs on a killed thread to do nothing", function(done) {
        var promise, sampleThread, status;
        status = {
          'resolved': false,
          'rejected': false
        };
        sampleThread = SimplyThread.create(FN.adder);
        sampleThread.kill();
        promise = sampleThread.run(1, 2);
        promise.then(function() {
          return status.resolved = true;
        });
        promise["catch"](function() {
          return status.rejected = true;
        });
        return setTimeout(function() {
          status.resolved.should.be["false"];
          status.rejected.should.be["false"];
          return done();
        }, 100);
      });
    });
    return suiteTeardown(function() {
      return SimplyThread.killAll();
    });
  });
});
